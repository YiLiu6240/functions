// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/myFunctions.h"
#include <RcppArmadillo.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// cbindARMA
arma::mat cbindARMA(const arma::mat& A, const arma::mat& B);
static SEXP myFunctions_cbindARMA_try(SEXP ASEXP, SEXP BSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat& >::type A(ASEXP );
        Rcpp::traits::input_parameter< const arma::mat& >::type B(BSEXP );
        arma::mat __result = cbindARMA(A, B);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_cbindARMA(SEXP ASEXP, SEXP BSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_cbindARMA_try(ASEXP, BSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// colSums
arma::vec colSums(const arma::mat& X);
static SEXP myFunctions_colSums_try(SEXP XSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP );
        arma::vec __result = colSums(X);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_colSums(SEXP XSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_colSums_try(XSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// convertToAlpha
double convertToAlpha(const double& mu, const double& s2);
static SEXP myFunctions_convertToAlpha_try(SEXP muSEXP, SEXP s2SEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const double& >::type mu(muSEXP );
        Rcpp::traits::input_parameter< const double& >::type s2(s2SEXP );
        double __result = convertToAlpha(mu, s2);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_convertToAlpha(SEXP muSEXP, SEXP s2SEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_convertToAlpha_try(muSEXP, s2SEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// convertToBeta
double convertToBeta(const double& mu, const double& s2);
static SEXP myFunctions_convertToBeta_try(SEXP muSEXP, SEXP s2SEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const double& >::type mu(muSEXP );
        Rcpp::traits::input_parameter< const double& >::type s2(s2SEXP );
        double __result = convertToBeta(mu, s2);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_convertToBeta(SEXP muSEXP, SEXP s2SEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_convertToBeta_try(muSEXP, s2SEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// dinvgammaArma
double dinvgammaArma(const double& x, const double& shape, const double& rate, const bool logarithm = true);
RcppExport SEXP myFunctions_dinvgammaArma(SEXP xSEXP, SEXP shapeSEXP, SEXP rateSEXP, SEXP logarithmSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< const double& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const double& >::type shape(shapeSEXP );
        Rcpp::traits::input_parameter< const double& >::type rate(rateSEXP );
        Rcpp::traits::input_parameter< const bool >::type logarithm(logarithmSEXP );
        double __result = dinvgammaArma(x, shape, rate, logarithm);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// dinvgammaArmaVec
arma::vec dinvgammaArmaVec(const arma::vec& x, const double& shape, const double& rate, const bool logarithm = true);
RcppExport SEXP myFunctions_dinvgammaArmaVec(SEXP xSEXP, SEXP shapeSEXP, SEXP rateSEXP, SEXP logarithmSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::RNGScope __rngScope;
        Rcpp::traits::input_parameter< const arma::vec& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const double& >::type shape(shapeSEXP );
        Rcpp::traits::input_parameter< const double& >::type rate(rateSEXP );
        Rcpp::traits::input_parameter< const bool >::type logarithm(logarithmSEXP );
        arma::vec __result = dinvgammaArmaVec(x, shape, rate, logarithm);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP
}
// dMVNorm
double dMVNorm(const arma::vec& y, const arma::vec& mu, const arma::mat& Sig);
static SEXP myFunctions_dMVNorm_try(SEXP ySEXP, SEXP muSEXP, SEXP SigSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::vec& >::type y(ySEXP );
        Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP );
        Rcpp::traits::input_parameter< const arma::mat& >::type Sig(SigSEXP );
        double __result = dMVNorm(y, mu, Sig);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_dMVNorm(SEXP ySEXP, SEXP muSEXP, SEXP SigSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_dMVNorm_try(ySEXP, muSEXP, SigSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// dmvnormArmaVec
arma::vec dmvnormArmaVec(const arma::vec& x, const arma::vec& mean, const arma::mat& Sigma, const bool logd = false);
static SEXP myFunctions_dmvnormArmaVec_try(SEXP xSEXP, SEXP meanSEXP, SEXP SigmaSEXP, SEXP logdSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::vec& >::type x(xSEXP );
        Rcpp::traits::input_parameter< const arma::vec& >::type mean(meanSEXP );
        Rcpp::traits::input_parameter< const arma::mat& >::type Sigma(SigmaSEXP );
        Rcpp::traits::input_parameter< const bool >::type logd(logdSEXP );
        arma::vec __result = dmvnormArmaVec(x, mean, Sigma, logd);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_dmvnormArmaVec(SEXP xSEXP, SEXP meanSEXP, SEXP SigmaSEXP, SEXP logdSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_dmvnormArmaVec_try(xSEXP, meanSEXP, SigmaSEXP, logdSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// phi
double phi(const double& x);
static SEXP myFunctions_phi_try(SEXP xSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const double& >::type x(xSEXP );
        double __result = phi(x);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_phi(SEXP xSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_phi_try(xSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// logDet
double logDet(const arma::mat Sig);
static SEXP myFunctions_logDet_try(SEXP SigSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat >::type Sig(SigSEXP );
        double __result = logDet(Sig);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_logDet(SEXP SigSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_logDet_try(SigSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// makeDistARMA
arma::mat makeDistARMA(const arma::mat& coords1, const arma::mat& coords2);
static SEXP myFunctions_makeDistARMA_try(SEXP coords1SEXP, SEXP coords2SEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat& >::type coords1(coords1SEXP );
        Rcpp::traits::input_parameter< const arma::mat& >::type coords2(coords2SEXP );
        arma::mat __result = makeDistARMA(coords1, coords2);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_makeDistARMA(SEXP coords1SEXP, SEXP coords2SEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_makeDistARMA_try(coords1SEXP, coords2SEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// makePCA
List makePCA(const arma::mat X);
static SEXP myFunctions_makePCA_try(SEXP XSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat >::type X(XSEXP );
        List __result = makePCA(X);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_makePCA(SEXP XSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_makePCA_try(XSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// mvrnormArma
arma::mat mvrnormArma(const int& n, const arma::vec& mu, const arma::mat& Sigma);
static SEXP myFunctions_mvrnormArma_try(SEXP nSEXP, SEXP muSEXP, SEXP SigmaSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const int& >::type n(nSEXP );
        Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP );
        Rcpp::traits::input_parameter< const arma::mat& >::type Sigma(SigmaSEXP );
        arma::mat __result = mvrnormArma(n, mu, Sigma);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_mvrnormArma(SEXP nSEXP, SEXP muSEXP, SEXP SigmaSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_mvrnormArma_try(nSEXP, muSEXP, SigmaSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// mvrnormArmaVec
arma::vec mvrnormArmaVec(const arma::vec& mu, const arma::mat& Sigma);
static SEXP myFunctions_mvrnormArmaVec_try(SEXP muSEXP, SEXP SigmaSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::vec& >::type mu(muSEXP );
        Rcpp::traits::input_parameter< const arma::mat& >::type Sigma(SigmaSEXP );
        arma::vec __result = mvrnormArmaVec(mu, Sigma);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_mvrnormArmaVec(SEXP muSEXP, SEXP SigmaSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_mvrnormArmaVec_try(muSEXP, SigmaSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// orderArma
IntegerVector orderArma(const NumericVector x);
static SEXP myFunctions_orderArma_try(SEXP xSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const NumericVector >::type x(xSEXP );
        IntegerVector __result = orderArma(x);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_orderArma(SEXP xSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_orderArma_try(xSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// rbindARMA
arma::mat rbindARMA(const arma::mat& A, const arma::mat& B);
static SEXP myFunctions_rbindARMA_try(SEXP ASEXP, SEXP BSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat& >::type A(ASEXP );
        Rcpp::traits::input_parameter< const arma::mat& >::type B(BSEXP );
        arma::mat __result = rbindARMA(A, B);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_rbindARMA(SEXP ASEXP, SEXP BSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_rbindARMA_try(ASEXP, BSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// rMVNArma
arma::vec rMVNArma(const arma::mat& A, const arma::vec& b);
static SEXP myFunctions_rMVNArma_try(SEXP ASEXP, SEXP bSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat& >::type A(ASEXP );
        Rcpp::traits::input_parameter< const arma::vec& >::type b(bSEXP );
        arma::vec __result = rMVNArma(A, b);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_rMVNArma(SEXP ASEXP, SEXP bSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_rMVNArma_try(ASEXP, bSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// rMVNArmaScalar
double rMVNArmaScalar(const double& a, const double& b);
static SEXP myFunctions_rMVNArmaScalar_try(SEXP aSEXP, SEXP bSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const double& >::type a(aSEXP );
        Rcpp::traits::input_parameter< const double& >::type b(bSEXP );
        double __result = rMVNArmaScalar(a, b);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_rMVNArmaScalar(SEXP aSEXP, SEXP bSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_rMVNArmaScalar_try(aSEXP, bSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// rowMeans
arma::vec rowMeans(const arma::mat& X);
static SEXP myFunctions_rowMeans_try(SEXP XSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP );
        arma::vec __result = rowMeans(X);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_rowMeans(SEXP XSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_rowMeans_try(XSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// rowSds
arma::vec rowSds(const arma::mat& X);
static SEXP myFunctions_rowSds_try(SEXP XSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP );
        arma::vec __result = rowSds(X);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_rowSds(SEXP XSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_rowSds_try(XSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// rowSums
arma::vec rowSums(const arma::mat& X);
static SEXP myFunctions_rowSums_try(SEXP XSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP );
        arma::vec __result = rowSums(X);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_rowSums(SEXP XSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_rowSums_try(XSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// svdARMA
List svdARMA(const arma::mat& X);
static SEXP myFunctions_svdARMA_try(SEXP XSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP );
        List __result = svdARMA(X);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_svdARMA(SEXP XSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_svdARMA_try(XSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}
// dcsvdARMA
List dcsvdARMA(const arma::mat& X);
static SEXP myFunctions_dcsvdARMA_try(SEXP XSEXP) {
BEGIN_RCPP
    SEXP __sexp_result;
    {
        Rcpp::traits::input_parameter< const arma::mat& >::type X(XSEXP );
        List __result = dcsvdARMA(X);
        PROTECT(__sexp_result = Rcpp::wrap(__result));
    }
    UNPROTECT(1);
    return __sexp_result;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP myFunctions_dcsvdARMA(SEXP XSEXP) {
    SEXP __result;
    {
        Rcpp::RNGScope __rngScope;
        __result = PROTECT(myFunctions_dcsvdARMA_try(XSEXP));
    }
    Rboolean __isInterrupt = Rf_inherits(__result, "interrupted-error");
    if (__isInterrupt) {
        UNPROTECT(1);
        Rf_onintr();
    }
    Rboolean __isError = Rf_inherits(__result, "try-error");
    if (__isError) {
        SEXP __msgSEXP = Rf_asChar(__result);
        UNPROTECT(1);
        Rf_error(CHAR(__msgSEXP));
    }
    UNPROTECT(1);
    return __result;
}

// validate (ensure exported C++ functions exist before calling them)
static int myFunctions_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("arma::mat(*cbindARMA)(const arma::mat&,const arma::mat&)");
        signatures.insert("arma::vec(*colSums)(const arma::mat&)");
        signatures.insert("double(*convertToAlpha)(const double&,const double&)");
        signatures.insert("double(*convertToBeta)(const double&,const double&)");
        signatures.insert("double(*dMVNorm)(const arma::vec&,const arma::vec&,const arma::mat&)");
        signatures.insert("arma::vec(*dmvnormArmaVec)(const arma::vec&,const arma::vec&,const arma::mat&,const bool)");
        signatures.insert("double(*phi)(const double&)");
        signatures.insert("double(*logDet)(const arma::mat)");
        signatures.insert("arma::mat(*makeDistARMA)(const arma::mat&,const arma::mat&)");
        signatures.insert("List(*makePCA)(const arma::mat)");
        signatures.insert("arma::mat(*mvrnormArma)(const int&,const arma::vec&,const arma::mat&)");
        signatures.insert("arma::vec(*mvrnormArmaVec)(const arma::vec&,const arma::mat&)");
        signatures.insert("IntegerVector(*orderArma)(const NumericVector)");
        signatures.insert("arma::mat(*rbindARMA)(const arma::mat&,const arma::mat&)");
        signatures.insert("arma::vec(*rMVNArma)(const arma::mat&,const arma::vec&)");
        signatures.insert("double(*rMVNArmaScalar)(const double&,const double&)");
        signatures.insert("arma::vec(*rowMeans)(const arma::mat&)");
        signatures.insert("arma::vec(*rowSds)(const arma::mat&)");
        signatures.insert("arma::vec(*rowSums)(const arma::mat&)");
        signatures.insert("List(*svdARMA)(const arma::mat&)");
        signatures.insert("List(*dcsvdARMA)(const arma::mat&)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP myFunctions_RcppExport_registerCCallable() { 
    R_RegisterCCallable("myFunctions", "myFunctions_cbindARMA", (DL_FUNC)myFunctions_cbindARMA_try);
    R_RegisterCCallable("myFunctions", "myFunctions_colSums", (DL_FUNC)myFunctions_colSums_try);
    R_RegisterCCallable("myFunctions", "myFunctions_convertToAlpha", (DL_FUNC)myFunctions_convertToAlpha_try);
    R_RegisterCCallable("myFunctions", "myFunctions_convertToBeta", (DL_FUNC)myFunctions_convertToBeta_try);
    R_RegisterCCallable("myFunctions", "myFunctions_dMVNorm", (DL_FUNC)myFunctions_dMVNorm_try);
    R_RegisterCCallable("myFunctions", "myFunctions_dmvnormArmaVec", (DL_FUNC)myFunctions_dmvnormArmaVec_try);
    R_RegisterCCallable("myFunctions", "myFunctions_phi", (DL_FUNC)myFunctions_phi_try);
    R_RegisterCCallable("myFunctions", "myFunctions_logDet", (DL_FUNC)myFunctions_logDet_try);
    R_RegisterCCallable("myFunctions", "myFunctions_makeDistARMA", (DL_FUNC)myFunctions_makeDistARMA_try);
    R_RegisterCCallable("myFunctions", "myFunctions_makePCA", (DL_FUNC)myFunctions_makePCA_try);
    R_RegisterCCallable("myFunctions", "myFunctions_mvrnormArma", (DL_FUNC)myFunctions_mvrnormArma_try);
    R_RegisterCCallable("myFunctions", "myFunctions_mvrnormArmaVec", (DL_FUNC)myFunctions_mvrnormArmaVec_try);
    R_RegisterCCallable("myFunctions", "myFunctions_orderArma", (DL_FUNC)myFunctions_orderArma_try);
    R_RegisterCCallable("myFunctions", "myFunctions_rbindARMA", (DL_FUNC)myFunctions_rbindARMA_try);
    R_RegisterCCallable("myFunctions", "myFunctions_rMVNArma", (DL_FUNC)myFunctions_rMVNArma_try);
    R_RegisterCCallable("myFunctions", "myFunctions_rMVNArmaScalar", (DL_FUNC)myFunctions_rMVNArmaScalar_try);
    R_RegisterCCallable("myFunctions", "myFunctions_rowMeans", (DL_FUNC)myFunctions_rowMeans_try);
    R_RegisterCCallable("myFunctions", "myFunctions_rowSds", (DL_FUNC)myFunctions_rowSds_try);
    R_RegisterCCallable("myFunctions", "myFunctions_rowSums", (DL_FUNC)myFunctions_rowSums_try);
    R_RegisterCCallable("myFunctions", "myFunctions_svdARMA", (DL_FUNC)myFunctions_svdARMA_try);
    R_RegisterCCallable("myFunctions", "myFunctions_dcsvdARMA", (DL_FUNC)myFunctions_dcsvdARMA_try);
    R_RegisterCCallable("myFunctions", "myFunctions_RcppExport_validate", (DL_FUNC)myFunctions_RcppExport_validate);
    return R_NilValue;
}
